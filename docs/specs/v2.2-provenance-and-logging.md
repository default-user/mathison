# v2.2 Provenance and Logging Specification

## Overview

Mathison v2.2 introduces comprehensive provenance tracking for all model invocations. Every call through the Model Bus generates an auditable event containing usage data, timing, and correlation identifiers.

## Provenance Event Structure

```typescript
interface ModelInvocationEvent {
  // Standard event fields
  event_id: string;           // Unique event ID
  namespace_id: string;       // OI namespace
  thread_id: string;          // Associated thread
  event_type: 'model_invocation';
  created_at: Date;

  // Provenance payload
  payload: {
    provider: string;         // 'openai' | 'anthropic' | 'local'
    model_id: string;         // Actual model used (e.g., 'gpt-4-turbo')
    usage: {
      input_tokens: number;
      output_tokens: number;
      total_tokens: number;
    };
    latency_ms: number;       // Time from request to response
    trace_id: string;         // Pipeline trace ID for correlation
    capability_token_id: string; // Token that authorized this call
    vendor_request_id?: string;  // Vendor's request ID (if available)
    finish_reason: 'stop' | 'length' | 'error' | 'content_filter';
  };
}
```

## What Is NOT Logged

For security and privacy reasons, the following are **intentionally excluded** from provenance events:

- **User message content**: Stored separately in thread messages, not in events
- **Assistant response content**: Stored separately in thread messages
- **API keys or credentials**: Never logged anywhere
- **Full request/response payloads**: Only metadata is logged

## Correlation

All components use the same `trace_id` for correlation:

```
HTTP Request
    └── trace_id: "abc-123"
         │
Pipeline Context
    └── trace_id: "abc-123"
         │
Model Router
    └── trace_id: "abc-123"
         │
Provenance Event
    └── trace_id: "abc-123"
```

This allows tracing a request from HTTP ingress through to the vendor API call and back.

## Logging Points

### 1. Handler Entry

When the `ai.chat` handler starts:

```typescript
// Recorded in pipeline execution log
{
  stage: 'handler_execution',
  started_at: Date,
  trace_id: string,
  intent: 'ai.chat',
  principal_id: string,
  oi_id: string
}
```

### 2. Model Invocation

When the model router calls an adapter:

```typescript
// Written to MemoryStore as event
await store.logEvent({
  namespace_id: payload.namespace_id,
  thread_id: payload.thread_id,
  event_type: 'model_invocation',
  payload: {
    provider: modelResponse.provenance.provider,
    model_id: modelResponse.provenance.model_id,
    usage: modelResponse.provenance.usage,
    latency_ms: latencyMs,
    trace_id: ctx.trace_id,
    capability_token_id: modelCapToken.token_id,
    vendor_request_id: modelResponse.provenance.vendor_request_id,
    finish_reason: modelResponse.finish_reason,
  },
}, tags);
```

### 3. Gateway Invocation Log

The AdapterGateway maintains an in-memory invocation log:

```typescript
interface InvocationLogEntry {
  id: string;
  type: 'model' | 'tool';
  target_id: string;      // model_id or tool_id
  allowed: boolean;       // Whether the call was permitted
  reason?: string;        // Why it was denied (if applicable)
  duration_ms?: number;   // How long the call took
  timestamp: Date;
}
```

## Querying Provenance

Provenance events can be queried through the MemoryStore:

```typescript
const events = await store.getEvents(
  namespace_id,
  {
    event_type: 'model_invocation',
    since: new Date('2024-01-01'),
    until: new Date(),
  },
  governanceTags
);

// Calculate total token usage
const totalTokens = events.reduce(
  (sum, e) => sum + (e.payload.usage?.total_tokens ?? 0),
  0
);
```

## Use Cases

### Cost Attribution

Sum `total_tokens` grouped by `namespace_id` to calculate per-OI costs:

```sql
SELECT namespace_id, SUM(payload->'usage'->>'total_tokens')
FROM events
WHERE event_type = 'model_invocation'
GROUP BY namespace_id;
```

### Performance Monitoring

Track `latency_ms` to identify slow model calls:

```sql
SELECT
  payload->>'model_id' as model,
  AVG((payload->>'latency_ms')::int) as avg_latency,
  MAX((payload->>'latency_ms')::int) as max_latency
FROM events
WHERE event_type = 'model_invocation'
GROUP BY payload->>'model_id';
```

### Audit Trail

Trace a specific request through the system:

```sql
SELECT * FROM events
WHERE payload->>'trace_id' = 'abc-123'
ORDER BY created_at;
```

### Capability Usage

Track which capability tokens authorized which calls:

```sql
SELECT
  payload->>'capability_token_id' as token_id,
  COUNT(*) as invocations
FROM events
WHERE event_type = 'model_invocation'
GROUP BY payload->>'capability_token_id';
```

## Security Considerations

1. **No Secrets in Logs**: API keys are never logged. Only token IDs (not tokens themselves) appear in events.

2. **Content Separation**: Message content is stored in thread messages, not in provenance events. This allows different retention policies.

3. **Namespace Isolation**: Events are namespaced and subject to the same access controls as other memory operations.

4. **Hash References**: When referencing sensitive data, use hashes or IDs rather than the actual data.
